## ğŸ“… Event Sorting in Google Calendar
# 1. ğŸ” Why Event Sorting?
While working on calendar events, I realized that sorting events by their start time or priority is crucial for a smooth user experience. It helps in displaying events in chronological order and quickly finding conflicts or free slots. To tackle this, I explored three classic sorting algorithms â€” Merge Sort, Quick Sort, and Heap Sort â€” to understand their strengths and use cases.

# ğŸ“Œ i. Merge Sort
Merge Sort is a divide-and-conquer algorithm. It splits the event list into halves, sorts each half recursively, and then merges the sorted halves. It's stable and great for large datasets where consistent performance is needed.

Hereâ€™s my C++ implementation:
```cpp
#include <vector>
using namespace std;

struct Event {
    int startTime;
    int endTime;
    string title;
};

void merge(vector<Event>& events, int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;

    vector<Event> L(n1);
    vector<Event> R(n2);

    for (int i = 0; i < n1; i++) L[i] = events[left + i];
    for (int i = 0; i < n2; i++) R[i] = events[mid + 1 + i];

    int i = 0, j = 0, k = left;
    while (i < n1 && j < n2) {
        if (L[i].startTime <= R[j].startTime) {
            events[k++] = L[i++];
        } else {
            events[k++] = R[j++];
        }
    }

    while (i < n1) events[k++] = L[i++];
    while (j < n2) events[k++] = R[j++];
}

void mergeSort(vector<Event>& events, int left, int right) {
    if (left >= right) return;
    int mid = left + (right - left) / 2;
    mergeSort(events, left, mid);
    mergeSort(events, mid + 1, right);
    merge(events, left, mid, right);
}
```
# ğŸŒ The Algo, My Way
Divides the events into halves recursively.

Merges them back sorted by start time.

Stable and consistent time complexity, even for large lists.

| Metric           | Merge Sort         |
|------------------|--------------------|
| Time Complexity  | O(n log n)         |
| Space Complexity | O(n)               |

# ğŸ“Œ ii. Quick Sort
Quick Sort is another divide-and-conquer algorithm that picks a pivot and partitions events into those before and after the pivot. It's generally faster than merge sort on average but not stable.

My C++ code for sorting events by start time:

```cpp
#include <vector>
using namespace std;

struct Event {
    int startTime;
    int endTime;
    string title;
};

int partition(vector<Event>& events, int low, int high) {
    Event pivot = events[high];
    int i = low - 1;
    for (int j = low; j < high; j++) {
        if (events[j].startTime <= pivot.startTime) {
            i++;
            swap(events[i], events[j]);
        }
    }
    swap(events[i + 1], events[high]);
    return i + 1;
}

void quickSort(vector<Event>& events, int low, int high) {
    if (low < high) {
        int pi = partition(events, low, high);
        quickSort(events, low, pi - 1);
        quickSort(events, pi + 1, high);
    }
}
```
# ğŸŒ The Algo, My Way
Selects a pivot event.

Partitions all events smaller or equal before the pivot.

Recursively sorts partitions.

Quick and in-place but not stable.

### Quick Sort Complexity

| Metric           | Quick Sort        |
|------------------|-------------------|
| Average Time     | O(n log n)        |
| Worst Time       | O(nÂ²)             |
| Space Complexity | O(log n) (stack)  |

# ğŸ“Œ iii. Heap Sort
Heap Sort uses a binary heap to sort events. It first builds a max-heap, then repeatedly extracts the maximum to get a sorted list. It's not stable but offers good worst-case performance.

My implementation for sorting events:
```cpp
#include <vector>
using namespace std;

struct Event {
    int startTime;
    int endTime;
    string title;
};

void heapify(vector<Event>& events, int n, int i) {
    int largest = i;
    int left = 2 * i + 1;
    int right = 2 * i + 2;

    if (left < n && events[left].startTime > events[largest].startTime)
        largest = left;
    if (right < n && events[right].startTime > events[largest].startTime)
        largest = right;

    if (largest != i) {
        swap(events[i], events[largest]);
        heapify(events, n, largest);
    }
}

void heapSort(vector<Event>& events) {
    int n = events.size();

    for (int i = n / 2 - 1; i >= 0; i--)
        heapify(events, n, i);

    for (int i = n - 1; i >= 0; i--) {
        swap(events[0], events[i]);
        heapify(events, i, 0);
    }
}
```
# ğŸŒ The Algo, My Way
Builds a max heap based on event start times.

Extracts max event and places it at the end.

Continues to sort in-place with O(n log n) worst-case.
### Heap Sort Complexity

| Metric           | Heap Sort          |
|------------------|--------------------|
| Time Complexity  | O(n log n)         |
| Space Complexity | O(1)               |


### Comparison Table

| Feature            | Merge Sort         | Quick Sort        | Heap Sort        |
|--------------------|--------------------|-------------------|------------------|
| Stability          | âœ… Stable          | âŒ Not stable     | âŒ Not stable    |
| Average Time       | O(n log n)         | O(n log n)        | O(n log n)       |
| Worst Time         | O(n log n)         | O(nÂ²)             | O(n log n)       |
| Space Usage        | O(n)               | O(log n)          | O(1)             |
| In-place           | âŒ                 | âœ…                | âœ…               |
| Use Case           | Large stable sort  | Fast average sort | In-place sorting |


# âœ… When to Use What?
Use Merge Sort when stability is required and space is not a constraint.

Use Quick Sort for faster average sorting and when in-place sorting is needed.

Use Heap Sort for guaranteed O(n log n) worst-case time and minimal space usage.

Sorting events right feels like organizing your day with precision! ğŸ—“ï¸âœ¨

