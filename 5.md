


# 🔍 Spell Correction Techniques in Search Engines

### ✨ Why Spell Correction?
When a user types “googel” instead of “google,” search engines shouldn’t throw errors — they should *help*. That’s where **spell correction** kicks in. Let’s dive into two of the most popular methods used behind the scenes.

---

## 📌 i. Levenshtein Distance

**Levenshtein Distance** is a metric that calculates the minimum number of single-character edits (insertions, deletions, or substitutions) required to change one word into another.

### ✒️ Example:
To transform `kitten` → `sitting`, we need:
- kitten → sitten (substitution of 'k' → 's')
- sitten → sittin (substitution of 'e' → 'i')
- sittin → sitting (insertion of 'g')

**Total edits**: 3

### ⚙️ How It Works

It builds a matrix comparing each character of both words and calculates the edit distance recursively.

### 🧠 In C++:

```cpp
int levenshtein(std::string a, std::string b) {
    int n = a.size(), m = b.size();
    std::vector<std::vector<int>> dp(n+1, std::vector<int>(m+1));

    for (int i = 0; i <= n; ++i)
        for (int j = 0; j <= m; ++j) {
            if (i == 0) dp[i][j] = j;
            else if (j == 0) dp[i][j] = i;
            else if (a[i-1] == b[j-1])
                dp[i][j] = dp[i-1][j-1];
            else
                dp[i][j] = 1 + std::min({ dp[i-1][j], dp[i][j-1], dp[i-1][j-1] });
        }

    return dp[n][m];
}
```

### 🌎 The Algo, My Way

> "Think of Levenshtein like a smart editor — figuring out the *least number of tweaks* needed to fix your typo."

### ⏱️ Time & Space Complexity
- **Time**: O(N × M)
- **Space**: O(N × M)

---

## 📌 ii. Trigram Matching

**Trigrams** are three-letter sequences from a word. It’s a form of *n-gram* analysis.

### ✒️ Example:
For the word `hello`, the trigrams are:
- `#he`, `hel`, `ell`, `llo`, `lo#`  
*(we usually pad with `#` to mark boundaries)*

### ⚙️ How It Works

1. Break both the misspelled and candidate words into trigrams.
2. Count the **intersection** between both trigram sets.
3. Rank candidate words by the **similarity score** (number of shared trigrams).

### 🧠 In C++:

```cpp
#include <iostream>
#include <vector>
#include <set>
#include <map>
#include <algorithm>

std::set<std::string> getTrigrams(std::string word) {
    word = "#" + word + "#";
    std::set<std::string> trigrams;
    for (int i = 0; i < word.size() - 2; ++i)
        trigrams.insert(word.substr(i, 3));
    return trigrams;
}

std::vector<std::pair<int, std::string>> trigramMatch(
    std::string input, std::vector<std::string> dictionary) {
    std::set<std::string> inputTrigrams = getTrigrams(input);
    std::vector<std::pair<int, std::string>> scoredWords;

    for (const auto& word : dictionary) {
        std::set<std::string> wordTrigrams = getTrigrams(word);
        int matchCount = 0;
        for (const auto& trigram : inputTrigrams) {
            if (wordTrigrams.count(trigram)) matchCount++;
        }
        scoredWords.push_back({matchCount, word});
    }

    std::sort(scoredWords.rbegin(), scoredWords.rend());
    return scoredWords;
}
```

### 🌎 The Algo, My Way

> "Trigram matching is like comparing fingerprints — the more patterns match, the closer the guess!"

### ⏱️ Time & Space Complexity
- **Time**: O(N × T), where N is number of words and T is average trigram count.
- **Space**: O(N × T)

---

## 🤖 Spell Correction in Action

Let’s say a user typed `pyhton` instead of `python`.

- 🔡 **Levenshtein Distance** would find `python` to be **1 edit away**.
- 📐 **Trigram Matching** might share trigrams like `#py`, `pyt`, `yth`, `tho`, `hon`, `on#`.

💡 Combining both gives the **most accurate correction**.

---

## 🧾 Summary: Which One to Use?

| Method              | Pros                                  | Best Use Case                          |
|---------------------|----------------------------------------|-----------------------------------------|
| **Levenshtein**     | Very accurate; edit distance-based     | Precise correction; short words         |
| **Trigram Matching**| Fast for large datasets; fuzzy matches | Autocomplete, suggestions, scalability  |

---

## 🎯 Bonus Tip: Combine Both!

> Use **trigrams** to filter top candidates, then apply **Levenshtein** to refine the results.  
> It’s like **first narrowing the search**, then **scoring the best match**.

---

### 📚 Fun Fact

🧠 Did you know?  
Google’s famous “Did you mean…” correction uses a combination of **edit distances, context awareness**, and **language models** to correct queries in milliseconds.


