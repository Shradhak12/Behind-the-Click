


# ğŸ” Spell Correction Techniques in Search Engines

### âœ¨ Why Spell Correction?
When a user types â€œgoogelâ€ instead of â€œgoogle,â€ search engines shouldnâ€™t throw errors â€” they should *help*. Thatâ€™s where **spell correction** kicks in. Letâ€™s dive into two of the most popular methods used behind the scenes.

---

## ğŸ“Œ i. Levenshtein Distance

**Levenshtein Distance** is a metric that calculates the minimum number of single-character edits (insertions, deletions, or substitutions) required to change one word into another.

### âœ’ï¸ Example:
To transform `kitten` â†’ `sitting`, we need:
- kitten â†’ sitten (substitution of 'k' â†’ 's')
- sitten â†’ sittin (substitution of 'e' â†’ 'i')
- sittin â†’ sitting (insertion of 'g')

**Total edits**: 3

### âš™ï¸ How It Works

It builds a matrix comparing each character of both words and calculates the edit distance recursively.

### ğŸ§  In C++:

```cpp
int levenshtein(std::string a, std::string b) {
    int n = a.size(), m = b.size();
    std::vector<std::vector<int>> dp(n+1, std::vector<int>(m+1));

    for (int i = 0; i <= n; ++i)
        for (int j = 0; j <= m; ++j) {
            if (i == 0) dp[i][j] = j;
            else if (j == 0) dp[i][j] = i;
            else if (a[i-1] == b[j-1])
                dp[i][j] = dp[i-1][j-1];
            else
                dp[i][j] = 1 + std::min({ dp[i-1][j], dp[i][j-1], dp[i-1][j-1] });
        }

    return dp[n][m];
}
```

### ğŸŒ The Algo, My Way

> "Think of Levenshtein like a smart editor â€” figuring out the *least number of tweaks* needed to fix your typo."

### â±ï¸ Time & Space Complexity
- **Time**: O(N Ã— M)
- **Space**: O(N Ã— M)

---

## ğŸ“Œ ii. Trigram Matching

**Trigrams** are three-letter sequences from a word. Itâ€™s a form of *n-gram* analysis.

### âœ’ï¸ Example:
For the word `hello`, the trigrams are:
- `#he`, `hel`, `ell`, `llo`, `lo#`  
*(we usually pad with `#` to mark boundaries)*

### âš™ï¸ How It Works

1. Break both the misspelled and candidate words into trigrams.
2. Count the **intersection** between both trigram sets.
3. Rank candidate words by the **similarity score** (number of shared trigrams).

### ğŸ§  In C++:

```cpp
#include <iostream>
#include <vector>
#include <set>
#include <map>
#include <algorithm>

std::set<std::string> getTrigrams(std::string word) {
    word = "#" + word + "#";
    std::set<std::string> trigrams;
    for (int i = 0; i < word.size() - 2; ++i)
        trigrams.insert(word.substr(i, 3));
    return trigrams;
}

std::vector<std::pair<int, std::string>> trigramMatch(
    std::string input, std::vector<std::string> dictionary) {
    std::set<std::string> inputTrigrams = getTrigrams(input);
    std::vector<std::pair<int, std::string>> scoredWords;

    for (const auto& word : dictionary) {
        std::set<std::string> wordTrigrams = getTrigrams(word);
        int matchCount = 0;
        for (const auto& trigram : inputTrigrams) {
            if (wordTrigrams.count(trigram)) matchCount++;
        }
        scoredWords.push_back({matchCount, word});
    }

    std::sort(scoredWords.rbegin(), scoredWords.rend());
    return scoredWords;
}
```

### ğŸŒ The Algo, My Way

> "Trigram matching is like comparing fingerprints â€” the more patterns match, the closer the guess!"

### â±ï¸ Time & Space Complexity
- **Time**: O(N Ã— T), where N is number of words and T is average trigram count.
- **Space**: O(N Ã— T)

---

## ğŸ¤– Spell Correction in Action

Letâ€™s say a user typed `pyhton` instead of `python`.

- ğŸ”¡ **Levenshtein Distance** would find `python` to be **1 edit away**.
- ğŸ“ **Trigram Matching** might share trigrams like `#py`, `pyt`, `yth`, `tho`, `hon`, `on#`.

ğŸ’¡ Combining both gives the **most accurate correction**.

---

## ğŸ§¾ Summary: Which One to Use?

| Method              | Pros                                  | Best Use Case                          |
|---------------------|----------------------------------------|-----------------------------------------|
| **Levenshtein**     | Very accurate; edit distance-based     | Precise correction; short words         |
| **Trigram Matching**| Fast for large datasets; fuzzy matches | Autocomplete, suggestions, scalability  |

---

## ğŸ¯ Bonus Tip: Combine Both!

> Use **trigrams** to filter top candidates, then apply **Levenshtein** to refine the results.  
> Itâ€™s like **first narrowing the search**, then **scoring the best match**.

---

### ğŸ“š Fun Fact

ğŸ§  Did you know?  
Googleâ€™s famous â€œDid you meanâ€¦â€ correction uses a combination of **edit distances, context awareness**, and **language models** to correct queries in milliseconds.


