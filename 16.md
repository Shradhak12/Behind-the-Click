## 🚀 Trending Detection in Video Platforms
# 1. 🔍 Why Trending Detection?
While exploring how platforms like YouTube detect what's trending, I found two powerful concepts that help analyze popularity over time: the Sliding Window technique and Heap-based Counters. These let us handle massive volumes of video views or interactions and highlight what’s popular right now.


# 📌 i. Sliding Window
The Sliding Window technique helps in maintaining real-time stats over a recent time range (like views in the last hour). It’s super helpful when trends need to reflect recent activity, not all-time stats.
 # ⚙️ My C++ Implementation:

 ```cpp
#include <deque>
#include <unordered_map>
using namespace std;

class SlidingWindowCounter {
    unordered_map<int, int> counter;
    deque<pair<int, int>> window;
    int windowSize; // in seconds

public:
    SlidingWindowCounter(int size) : windowSize(size) {}

    void add(int timestamp, int videoId) {
        window.push_back({timestamp, videoId});
        counter[videoId]++;

        while (!window.empty() && timestamp - window.front().first > windowSize) {
            int oldId = window.front().second;
            window.pop_front();
            counter[oldId]--;
            if (counter[oldId] == 0) counter.erase(oldId);
        }
    }

    unordered_map<int, int> getTrending() {
        return counter;
    }
};
```
## 🌍 The Algo, My Way
Keeps only the recent window of events (like last 10 mins).

Automatically evicts old entries, keeping memory small.

Best for dynamic trends — "what’s hot right now."

# 📊 Time & Space Complexity: Sliding Window

| Operation         | Time Complexity | Space Complexity |
|------------------|------------------|------------------|
| Add interaction   | O(1)             | O(W)             |
| Get trending      | O(1)             | O(W)             |

_W = size of the time window_

# 📌 ii. Heap-based Counters
While experimenting with Heap-based Counters, I realized it’s perfect for maintaining a Top-K list of trending videos. It can continuously rank items by frequency using a min-heap or priority queue.

⚙️ My C++ Implementation:
```cpp
#include <unordered_map>
#include <queue>
#include <vector>
using namespace std;

class TrendingHeap {
    unordered_map<int, int> freq;
    int k;

public:
    TrendingHeap(int topK) : k(topK) {}

    void addInteraction(int videoId) {
        freq[videoId]++;
    }

    vector<pair<int, int>> getTopKTrending() {
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> minHeap;

        for (auto& [id, count] : freq) {
            minHeap.push({count, id});
            if (minHeap.size() > k)
                minHeap.pop();
        }

        vector<pair<int, int>> result;
        while (!minHeap.empty()) {
            result.push_back(minHeap.top());
            minHeap.pop();
        }

        reverse(result.begin(), result.end());
        return result;
    }
};
```
# 🌍 The Algo, My Way
Great when you want a Top-K trending list.

Uses a min-heap to keep the smallest of the top.

Slightly slower than sliding window but gives rankings!

| Operation         | Time Complexity | Space Complexity |
|------------------|------------------|------------------|
| Add interaction   | O(1)             | O(n)             |
| Get Top-K         | O(n log k)       | O(n)             |

_n = number of distinct videos_

# 🔄 Comparison Table


| Feature               | Sliding Window            | Heap-based Counter           |
|-----------------------|---------------------------|------------------------------|
| **Focus**             | Recent trends             | Top-K popular items          |
| **Memory-efficient**  | ✅ (evicts old)            | ❌ (stores all frequencies)  |
| **Use case**          | Real-time detection       | Leaderboards, rankings       |
| **Ranking support**   | ❌ (only counts)           | ✅ (gives sorted top-K)       |
| **Speed**             | Very fast (O(1))          | Slightly slower (O(n log k)) |


