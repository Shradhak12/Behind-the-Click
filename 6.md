# 🌐 Shortest Path Algorithms – Navigating the Web Maze

Ever wondered how navigation apps like Google Maps or food delivery services calculate the shortest path between two locations? 🗺️ That’s where shortest path algorithms come into play. Let’s explore three powerful algorithms used in pathfinding:

---

## 1. 🛣️ Dijkstra’s Algorithm – The Reliable Navigator

Think of Dijkstra’s as the "safe driver" of pathfinding. It always explores the lowest-cost route first, ensuring you reach the destination with minimal cost (or distance).

📌 **How It Works**  
It starts at the source node, explores neighbors with the smallest known cost, and updates the distances until the shortest paths to all nodes are found.

```cpp
#include <vector>
#include <queue>
#include <utility>
#include <limits>

const int INF = std::numeric_limits<int>::max();

std::vector<int> dijkstra(int start, const std::vector<std::vector<std::pair<int, int>>>& graph) {
    int n = graph.size();
    std::vector<int> dist(n, INF);
    dist[start] = 0;

    using pii = std::pair<int, int>;
    std::priority_queue<pii, std::vector<pii>, std::greater<pii>> pq;
    pq.push({0, start});

    while (!pq.empty()) {
        int d = pq.top().first;
        int u = pq.top().second;
        pq.pop();

        if (d > dist[u]) continue;

        for (auto& [v, w] : graph[u]) {
            if (dist[u] + w < dist[v]) {
                dist[v] = dist[u] + w;
                pq.push({dist[v], v});
            }
        }
    }

    return dist;
}
```
##🌎 The Algo, My Way

Imagine each city is a node.

Roads between them are edges with weights.

Use a min-heap (priority queue) to always explore the cheapest road.

⏱️ Time & Space Complexity

Time: O((V + E) log V)

Space: O(V)

## 2. ✨ A* Search – Smarter Navigation with Hints
A* is Dijkstra’s clever cousin. It uses heuristics (guesses) to speed things up. Think of it like Google Maps saying: “Hmm, I think this road gets me closer to the target.”

📌 How It Works
Adds a heuristic function h(n) to guess the remaining distance to the target. It prioritizes paths that look promising.

```cpp
#include <vector>
#include <queue>
#include <cmath>
#include <utility>
#include <limits>

struct Node {
    int index;
    int cost;
    int estimated_total;
    bool operator>(const Node& other) const {
        return estimated_total > other.estimated_total;
    }
};

int heuristic(int a, int b) {
    return std::abs(a - b); // Use domain-specific heuristic here
}

std::vector<int> a_star(int start, int goal, const std::vector<std::vector<std::pair<int, int>>>& graph) {
    int n = graph.size();
    std::vector<int> dist(n, INF);
    dist[start] = 0;

    std::priority_queue<Node, std::vector<Node>, std::greater<Node>> pq;
    pq.push({start, 0, heuristic(start, goal)});

    while (!pq.empty()) {
        Node current = pq.top();
        pq.pop();

        if (current.index == goal) break;

        for (auto& [neighbor, weight] : graph[current.index]) {
            int tentative = dist[current.index] + weight;
            if (tentative < dist[neighbor]) {
                dist[neighbor] = tentative;
                int est_total = tentative + heuristic(neighbor, goal);
                pq.push({neighbor, tentative, est_total});
            }
        }
    }

    return dist;
}
```
🌎 The Algo, My Way

Like Dijkstra, but now I’m using intuition to guide faster.

The heuristic helps avoid exploring useless paths.

⏱️ Time & Space Complexity

Time: O(E), but depends on heuristic

Space: O(V)

### 3. ⚖️ Bellman-Ford – Handles Negative Roads
Unlike Dijkstra, Bellman-Ford can handle roads with toll refunds (negative weights)! 🧾

📌 How It Works
Iteratively relaxes all edges V-1 times. If distances still reduce in Vth iteration, there's a negative cycle.

```cpp
#include <vector>
#include <limits>

std::vector<int> bellman_ford(int start, int V, const std::vector<std::tuple<int, int, int>>& edges) {
    std::vector<int> dist(V, INF);
    dist[start] = 0;

    for (int i = 0; i < V - 1; ++i) {
        for (auto& [u, v, w] : edges) {
            if (dist[u] != INF && dist[u] + w < dist[v]) {
                dist[v] = dist[u] + w;
            }
        }
    }

    // Check for negative cycles
    for (auto& [u, v, w] : edges) {
        if (dist[u] != INF && dist[u] + w < dist[v]) {
            throw std::runtime_error("Negative weight cycle detected");
        }
    }

    return dist;
}
```
🌎 The Algo, My Way

Try relaxing all roads repeatedly.

If cost still decreases after V-1 tries, something fishy is going on (hello, negative cycle)!

⏱️ Time & Space Complexity

Time: O(V × E)

Space: O(V)

✅ When Should I Use What?

Use Dijkstra when weights are non-negative and you want reliability.

Use A* when you can guess distances (like map coordinates).

Use Bellman-Ford when there’s a chance of negative weights (e.g., in financial graphs).

