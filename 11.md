# 🔎 Step 2: Searching for Videos
# 1. 🔍 Why Video Search?
While exploring how YouTube and other video platforms let users search inside videos — like finding spoken words, captions, or repeated phrases — I realized that efficient string matching is the key. Two powerful tools caught my attention: Suffix Arrays and Knuth-Morris-Pratt (KMP) algorithm.

Let me walk you through how I understood and implemented them!
# 📌 i. Suffix Array
Suffix Arrays are a sorted array of all suffixes of a string. They allow fast substring searching — perfect for video transcript indexing where phrases or dialogues need to be located quickly.

🧠 My Implementation in C++
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

vector<int> buildSuffixArray(const string& text) {
    int n = text.length();
    vector<pair<string, int>> suffixes;
    for (int i = 0; i < n; i++)
        suffixes.push_back({text.substr(i), i});

    sort(suffixes.begin(), suffixes.end());

    vector<int> suffixArray;
    for (auto& s : suffixes)
        suffixArray.push_back(s.second);

    return suffixArray;
}

vector<int> search(const string& pattern, const string& text, const vector<int>& suffixArray) {
    int n = text.size(), m = pattern.size();
    int low = 0, high = n - 1;
    vector<int> result;

    while (low <= high) {
        int mid = (low + high) / 2;
        string suffix = text.substr(suffixArray[mid], m);
        if (suffix == pattern) {
            result.push_back(suffixArray[mid]);
            break;
        } else if (suffix < pattern) {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }

    return result;
}
```
## 🌍 The Algo, My Way


# Time and Space Complexity: Suffix Array

| Operation         | Time Complexity | Space Complexity |
|------------------|------------------|------------------|
| Build Suffix Array | O(n log n)       | O(n)             |
| Search Pattern     | O(m log n)       | O(1)             |

# 📌 ii. KMP (Knuth-Morris-Pratt)
KMP blew my mind — it avoids rechecking characters during mismatches by using a prefix table. This makes it ideal for real-time search, like looking for frames containing a specific dialogue line in real time.

🧠 My Implementation in C++
```cpp
#include <iostream>
#include <vector>
using namespace std;

vector<int> buildLPS(const string& pattern) {
    int m = pattern.size();
    vector<int> lps(m, 0);
    int len = 0;

    for (int i = 1; i < m; ) {
        if (pattern[i] == pattern[len]) {
            lps[i++] = ++len;
        } else {
            if (len != 0) len = lps[len - 1];
            else i++;
        }
    }

    return lps;
}

vector<int> KMPSearch(const string& text, const string& pattern) {
    int n = text.size(), m = pattern.size();
    vector<int> lps = buildLPS(pattern);
    vector<int> result;

    int i = 0, j = 0;
    while (i < n) {
        if (text[i] == pattern[j]) {
            i++, j++;
        }

        if (j == m) {
            result.push_back(i - j);
            j = lps[j - 1];
        } else if (i < n && text[i] != pattern[j]) {
            if (j != 0) j = lps[j - 1];
            else i++;
        }
    }

    return result;
}
```
# 🌍 The Algo, My Way

#  Time and Space Complexity: KMP (Knuth-Morris-Pratt)


| Operation            | Time Complexity | Space Complexity |
|----------------------|------------------|------------------|
| Build LPS Array      | O(m)             | O(m)             |
| Search Pattern       | O(n)             | O(n + m)         |


 # 🔄 Comparison Table: Suffix Array vs KMP

| Feature             | Suffix Array             | KMP                         |
|---------------------|--------------------------|------------------------------|
| **Best for**        | Static transcript search | Real-time search             |
| **Search Speed**    | O(m log n)               | O(n)                         |
| **Preprocessing**   | O(n log n)               | O(m)                         |
| **Use case**        | Phrase location          | Instant matching while watching |
| **Space Usage**     | Moderate                 | Low                          |
| **Supports prefix** | ✅                       | ✅                           |

### ✅ When to Use Which?

Use **Suffix Array** when:

📚 You have a **static transcript or large video metadata**  
🔍 You need **fast repeated searches** (e.g., multiple users querying the same video content)  
🔎 Ideal for **offline indexing** of dialogues, captions, or subtitles  

Use **KMP** when:

⚡ You need **real-time search** while the video is playing  
🧠 You want to **detect patterns or phrases** as they occur live  
📺 Best for **interactive experiences** like "skip to this line" during playback  

